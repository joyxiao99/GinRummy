\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{adjustbox}

% Strikethrough
\usepackage{ulem}

\title{SFWRENG 3XA3: Test Plan}

\author{Lab 2 Group 7, Rummy For Dummies
		\\ Joy Xiao, xiaoz18
		\\ Benson Hall, hallb8
		\\ Smita Singh, sings59
}

\date{April 09, 2021}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
February 26, 2021 & 1.0 & Started on test plan \\
March 5, 2021 & 1.1 & Finished the test plan and matrix \\
April 09, 2021 & 2.0 & Finished test plan revision 1 \\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\section{General Information}
\subsection{Purpose}
The purpose of the document is to outline the testing plan for Rummy for Dummies. The test cases will cover all functional and non-functional requirements, and elaborate on the details behind the tests being written and executed. Through the test cases, confidence can be achieved that the game can be played without error.

\subsection{Scope}
The test plan provides the space for testing the functional and non-functional requirements of Rummy for Dummies. The objective of the test plan is to prove that a full game of Gin-Rummy can be played without any error. The game will be able to be played with valid inputs from the user and any invalid inputs will be handled appropriately.

Additionally, the test plan will act as a schedule for all test-based activities. The test plan will outline all testing methods and tools that will be used.

\subsection{Acronyms, Abbreviations, and Symbols}
	
\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}}
\label{TableAbbrev}
\centering
\begin{tabular}{|c|c|}
    \hline
    \textbf{Abbreviation} & \textbf{Definition} \\
    \hline
    PoC & Proof of Concept \\
    \hline
    CLI & Command Line Interface \\
    \hline
\end{tabular}

\end{table}

\begin{table}[H]
\caption{\textbf{Table of Definitions}}
\label{TableDef}
\centering
\begin{tabular}{|c|c|}
    \hline
    \textbf{Term} & \textbf{Definition}\\
    \hline
    Automated Testing & Testing that uses software separate to the software \\ 
    & being tested to handle execution of tests \\
    \hline
    Manual Testing & Testing that requires human intervention or input \\
    & to handle execution of tests \\
    \hline
    Statement Coverage & A test suite achieves statement coverage if it results \\
     & in every statement in the program to be run at least once \\
    \hline
    Branch Coverage & A test suite achieves branch coverage if it results \\
     & in every branch being taken at least once \\
    \hline
    Condition Coverage & A test suite achieves condition coverage if it results \\
     & in each condition in each branching instruction being both \\ 
     & true and false \\
    \hline
\end{tabular}

\end{table}	

\subsection{Overview of Document}
In the document, Section 2 will detail the plan for future tests on Rummy for Dummies. Section 3 will describe all tests that will be conducted on the system. Section 4 will discuss tests for the PoC. Section 5 will discuss the tests that will be used to compare between Rummy for Dummies and the original source code project. Section 6 will explain the unit testing plan.

\section{Plan}
\subsection{Software Description}
The software is a single-player card game implementation of Gin-Rummy with a computer opponent. This game is implemented in Java.

\subsection{Test Team}
The individuals listed below will be responsible for writing and executing all test cases, and ensuring that Rummy for Dummies passes all these tests.
\begin{itemize}
    \item Joy Xiao
    \item Benson Hall
    \item Smita Singh
\end{itemize}

\subsection{Automated Testing Approach}
Most tests performed on methods will be automated, while other tests such as integration tests will be manually conducted. In these integration tests, the JUnit assertion statements will not be utilized. Instead, testers will manually check printed results on the console/CLI for the correct output.

\subsection{Testing Tools}
All tests will be written using the JUnit framework. 

\subsection{Testing Schedule}
		
The Gantt chart can be found \href{https://gitlab.cas.mcmaster.ca/xiaoz18/3xa3-project/-/blob/master/ProjectSchedule/3XA3-project.gan}{here}

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}
		
\subsubsection{Card Tests}
% Card Test %
\begin{enumerate}

    \item {FR-C-1: Test accessor for card suit}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: Card \textcolor{red}{\sout{card1}} = new Card(Suit.D, 1)\textcolor{red}{\sout{;}}
    					
    Input: \textcolor{red}{\sout{card1} Card}
    					
    Output: Suit.D
    					
    How test will be performed: Call Card.getSuit and see if it matches expected output
    
    \item {FR-C-2: Test \textcolor{red}{ constructor with invalid rank.  \textcolor{red}{\sout{accessor for card rank}}}}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: \textcolor{red}{\sout{ Card \textcolor{red}{\sout{card1}} = new Card(Suit.D, -1)}} N/a
    					
    Input:  \textcolor{red}{\sout{card1}} Card = new Card(Suit.D, -1)
    					
    Output: \textcolor{red}{\sout{Invalid Rank Exception} IllegalArgumentException}
    					
    How test will be performed: \textcolor{red}{\sout{ Call Card.getRank and see if it matches expected output}} The card constructor is called when the card is intialized.
    
    \item{FR-C-3: Test accessor for point value of card (I)}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: Card \textcolor{red}{\sout{card1}} = new Card(Suit.D, 11);
    					
    Input:  \textcolor{red}{\sout{card1} Card}
    					
    Output: 10
    					
    How test will be performed: Call Card.points and see if it matches expected output
    
    \item{FR-C-4: Test accessor for point value of card (II)}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: Card \sout{card1} = new Card(Suit.C, 2);
    					
    Input:  \textcolor{red}{\sout{card1} Card}
    					
    Output: 2
    					
    How test will be performed: Call Card.points and see if it matches expected output
    
    \item{FR-C-5: Test String representation of card (I)}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: Card \textcolor{red}{\sout{=card1}} = new Card(Suit.H, 11);
    					
    Input:  \textcolor{red}{\sout{card1} Card}
    					
    Output: "Jh"
    					
    How test will be performed: Call Card.toString and see if it matches expected output
    
    \item{FR-C-6: Test String representation of card (II)}
    
    Type: Unit test, functional, dynamic, automated
    					
    Initial State: Card \textcolor{red}{\sout{=card1}} = new Card(Suit.C, 2);
    					
    Input:  \textcolor{red}{\sout{card1} Card}
    					
    Output: "2c"
    					
    How test will be performed: Call Card.toString and see if it matches expected output
    
    
    \item \textcolor{red}{FR-C-7: Test Symbol representation of card}
    
    \textcolor{red}{Type: Unit test, functional, dynamic, automated}
    					
    \textcolor{red}{Initial State: Card  = new Card(Suit.S, 11)}
    					
    \textcolor{red}{Input:  Card}
    					
    \textcolor{red}{Output: "J spade symbol"}
    					
    \textcolor{red}{How test will be performed: Call Card.toSymbol and see if it matches expected output}
    
     \item \textcolor{red}{FR-C-8: Test getRank method}
    
    \textcolor{red}{Type: Unit test, functional, dynamic, automated}
    					
    \textcolor{red}{Initial State: Card  = new Card(Suit.D, 1)}
    					
    \textcolor{red}{Input:  Card}
    					
    \textcolor{red}{Output: "1"}
    					
    \textcolor{red}{How test will be performed: Call Card.getRank and see if it matches expected output}

\end{enumerate}

\subsubsection{Discard Pile Tests}
% Discard Pile Test %
\begin{enumerate}
    \item{FR-DP-1: Test display of discard pile}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial State: DiscardPile = [5h, 9d]
    
    Input: DiscardPile.displayTopCard
    
    Output: 9h displayed
    					
    How test will be performed: Call DiscardPile.displayTopCard
    
    \item{FR-DP-2: Test drawing card from discard pile}
    
    Type: Unit test, functional test, dynamic, automated 
    Initial State: DiscardPile = [5h, 9d]

    Input: DiscardPile.pop
        
    Output: DiscardPile = [5h]
    					
    How test will be performed: Call DiscardPile.pop
\end{enumerate}

\subsubsection{Stock Pile Tests}
% Stock Pile Tests %
\begin{enumerate}
    \item{FR-SP-1: Test drawing from stock pile with 1 or more cards}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial State: StockPile = [As, 5d]
    
    Input: Stockpile.pop
    
    Output: Stock pile = [As]
    
    How test will be performed: Call StockPile.pop
    
    \item{\textcolor{red}{\sout{FR-SP-2: Test drawing from stock pile with 0 cards}}}
    
    \textcolor{red}{\sout{Type: Integration test, functional test, dynamic, automated}}
    
    \textcolor{red}{\sout{Initial state: StockPile = []}}
    
    \textcolor{red}{\sout{Input: Stockpile.pop}}
    
    \textcolor{red}{\sout{Output: Does not allow player to draw from the stock pile. No error thrown. User prompted to choose another selection.}}
    					
    \textcolor{red}{\sout{How test will be performed: Call StockPile.pop}}
\end{enumerate}

\subsubsection{Computer Tests}
% Computer Tests %
\begin{enumerate}
    \item{FR-CP-1: Test computer make move method (I)}
    
    Type: Integration test, functional test, dynamic, \textcolor{red}{\sout{manual}}, \textcolor{red}{automated} 
    					
    Initial state: DiscardPile = [4h, 9c, 5d], Computer Hand = [4d, 6d, Ks, Js, Ad, 2d], StockPile = [Qs, 3d]
    		
    Input: Computer.makeMove
    
    Output: DiscardPile = [4h, 9c, \textcolor{red}{\sout{5d}}, Ks], Computer Hand = [4d, 6d, Js, Ad, 2d, 5d], StockPile = [Qs, 3d]. Returns False.
    					
    How test will be performed: Call Computer.makeMove method. \textcolor{red}{\sout{Manually check output}}
    
    \item{FR-CP-2: Test computer make move method (II)}
    
    Type: Integration test, functional test, dynamic, \textcolor{red}{\sout{manual}}, \textcolor{red}{automated} 
    					
    Initial state: DiscardPile = [4h, Jc, 10d, Ks], Computer Hand = [4d, 6d, Js, Ad, 2d, 5d], StockPile = [Qs, 3d]
    		
    Input: Computer.makeMove
    
    Output: DiscardPile = [4h, Jc, 10d, Ks, Js], Computer Hand = [4d, 6d, Ad, 2d, 5d, 3d], StockPile = [Qs]. Returns False.
    					
    How test will be performed: Call Computer.makeMove method.\textcolor{red}{\sout{Manually check output}}
    
    \item{FR-CP-3: Test computer make move method (III)}
    
    Type: Integration test, functional test, dynamic, \textcolor{red}{\sout{manual}}, \textcolor{red}{automated} 
    Initial state: DiscardPile = [4h, Jc, 10d, As], Computer Hand = [4d, 6d, Js, Ad, 2d, 5d], StockPile = [Qs, 3d]
    		
    Input: Computer.makeMove
    
    Output: DiscardPile = [4h, Jc, 10d, Js], Computer Hand = [4d, 6d, Ad, 2d, 5d, As], StockPile = [Qs, 3d]. Returns False.
    					
    How test will be performed: Call Computer.makeMove method. \textcolor{red}{\sout{Manually check output}}
    
    \item{FR-CP-4: Test that computer never discards a meld card \textcolor{red}{(I)}}
    
    Type: Integration test, functional test, dynamic, \textcolor{red}{\sout{manual}}, \textcolor{red}{automated}
    					
    Initial state: DiscardPile = [4h, Jc, 10d, As], Computer Hand = [4d, 6d, Ad, 2d, Kc, Kd, Ks], StockPile = [Qs, 3d]

    Input: Computer.makeMove
    
    Output: DiscardPile = [4h, Jc, 10d, 6d], Computer Hand = [4d, Ad, 2d, Kc, Kd, Ks, As], StockPile = [Qs, 3d]. Returns False.
    					
    How test will be performed: Call Computer.makeMove. \textcolor{red}{\sout{Manual check printing out the computer's hand every turn and to make sure meld cards are never discarded}}

    \item{FR-CP-5: Test that computer never discards a meld card \textcolor{red}{(II)}}
    
    Type: Integration test, functional test, dynamic, \textcolor{red}{\sout{manual}}, \textcolor{red}{automated} 
    					
    Initial state: DiscardPile = [4h, Jd, 10d, As], Computer Hand = [4d, 6d, Ad, 2d, Jc, Qc, Kc], StockPile = [Qs, 3d]

    Input: Computer.makeMove
    
    Output: DiscardPile = [4h, Jd, 10d, \textcolor{red}{\sout{As}}, \textcolor{red}{6d}], Computer Hand = [4d, Ad, 2d, Jc, Qc, Kc, As], StockPile = [Qs, 3d]. Returns False.
    					
    How test will be performed: Call Computer.makeMove. \textcolor{red}{\sout{Manual check printing out the computer's hand every turn and to make sure meld cards are never discarded}}
    
    \item{FR-CP-6: Test that computer knocks whenever it's hand has deadwood score of 10 or less}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial state: \textcolor{red}{DiscardPile = [], StockPile = [],} Computer Hand = [4d, Ad, 2d, Jc, Qc, Kc, As]
    
    Input: computer.makeMove
    
    Output: Returns True
    
    How test will be performed: Call computer.makeMove
    
    \item{\textcolor{red}{FR-CP-7: Test computer move when discard pile has 1 card}}
    
    \textcolor{red}{Type: Unit test, functional test, dynamic, automated}

    \textcolor{red}{Initial state: DiscardPile = [4h], StockPile = [Qs, 3d], Computer Hand = [4d, 6d, Js, Ad, 2d, 5d]}
    
    \textcolor{red}{Input: computer.makeMove}
    
    \textcolor{red}{Output: DiscardPile = [Js], StockPile = [Qs, 3d], Computer Hand = [4d, 6d, Ad, 2d, 5d, 4h]. Returns False.}
    
    \textcolor{red}{How test will be performed: Call computer.makeMove}
   
     \item{\textcolor{red}{FR-CP-8: Test computer does not draw from empty stock pile}}
    
    \textcolor{red}{Type: Unit test, functional test, dynamic, automated}
    
    \textcolor{red}{Initial state: DiscardPile = [4h], StockPile = [], Computer Hand = [4d, 6d, Js, Ad, 2d, 5d]}
    
    \textcolor{red}{Input: computer.makeMove}
    
    \textcolor{red}{Output: DiscardPile = [Js], StockPile = [], Computer Hand = [4d, 6d, Ad, 2d, 5d, 4h]. Returns False.}
    					
    \textcolor{red}{How test will be performed: Call computer.makeMove}
\end{enumerate}

\subsubsection{Hand Tests}
% Hand Test %
\begin{enumerate}
    \item{FR-H-1: Test remove card from hand (I)}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: "As"
    
    Output: hand = [2s, Qs, 3d, 5d]
    
    How test will be performed: Call Hand.remove 
    
    \item{FR-H-2: Test remove card from hand (II)}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: "Kc"
    
    Output: hand = [As, 2s, Qs, 3d, 5d]
    
    How test will be performed: Call Hand.remove
    
    \item{FR-H-3: Test remove card from hand (III)}
    
    Type: Unit test, functional test, dynamic, automated 
    					
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: "AS"
    
    Output: hand = [2s, Qs, 3d, 5d]
    
    How test will be performed: Call Hand.remove
    
    \item{FR-H-4: Test remove card from hand (IV)}
    
    Type: Unit test, functional test, dynamic, automated
    
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: "KS"
    
    Output: hand = [As, 2s, Qs, 3d, 5d]
    
    How test will be performed: Call Hand.remove
    
    \item{FR-H-5: Test displaying of hand}
    
    Type: Unit test, functional test, dynamic, manual 
    					
    Initial state: Player object initialized with a non-empty hand
    
    Input: Hand
    
    Output: All cards in player's hand is displayed correctly
    
    How test will be performed: Call Hand.display
    
    \item{FR-H-6: Test contains method (I)}
    
    Type: Unit test, functional test, dynamic, automated
    
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: input = "As"
    
    Output: Return True
    
    How test will be performed: Call Hand.contains
    
    \item{FR-H-7: Test contains method (II)}
    
    Type: Unit test, functional test, dynamic, automated
    
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: input = "Ks"
    
    Output: Return False
    
    How test will be performed: Call Hand.contains
    
    \item{FR-H-8: Test contains method (III)}
    
    Type: Unit test, functional test, dynamic, automated
    
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: input = "AS"
    
    Output: Return True
    
    How test will be performed: Call Hand.contains
    
    \item{FR-H-9: Test contains method (IV)}
    
    Type: Unit test, functional test, dynamic, automated
    
    Initial state: hand = [As, 2s, Qs, 3d, 5d]
    
    Input: input = "KS"
    
    Output: Return False
    
    How test will be performed: Call Hand.contains
\end{enumerate}

\subsubsection{Player Tests}
% Player Tests %
\begin{enumerate}
    \item{FR-P-1: Test accessor for player's name}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: Player p = new Player("P1");
    
    Input: p
    
    Output: "P1"
    
    How test will be performed: Call Player.getName and check that the name matches
    
    \item{FR-P-\textcolor{red}{\sout{6}2}: Test adding a card to player's hand}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = \textcolor{red}{\sout{[Ah, Ac, 4d, 5s, 10h]}[Ah, 2s, Qs, 3d, 5d]};
    
    Input: p, new Card(Suit.S, 1\textcolor{red}{3\sout{2}})
    
    Output: p.hand = \textcolor{red}{\sout{[Ah, Ac, 4d, 5s, 10h, Qs]}[Ah, 2s, Qs, 3d, 5d, Ks]};
    
    How test will be performed: Call Player.addCardToHand method with the Card object as a parameter. Call Player.getHand to verify that the new card has been added to the hand
    
    \item{FR-P-\textcolor{red}{\sout{2}3}: Test accessor for player's hand}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = [Ah, 2s, Qs, 3d, 5d];
    
    Input: p
    
    Output: hand = [Ah, 2s, Qs, 3d, 5d]
    
    How test will be performed: Call Player.getHand and check that assigned hand matches received object
    
    \item{FR-P-\textcolor{red}{\sout{3}4}: Test accessor for player's total score}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.totalScore = 12;
    
    Input: p
    
    Output: totalScore = 12
    
    How test will be performed: Call Player.getTotalScore and check that assigned score matches score received from call
    
    \item{FR-P-\textcolor{red}{\sout{4}5}: Test accessor for player's deadwood score}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = \textcolor{red}{\sout{[Ah, Ac, Ad, As, 2s, Jh, Qs, 9h]}[Ah, Ac, Ad, As, 2s, 2c, 2d, 3d, Qs, 9h]}
    
    Input: p
    
    Output: deadwoodScore = \textcolor{red}{\sout{2 + 10 + 10 + 9 = 31} 3 + 10 + 9 = 22}
    
    How test will be performed: Call Player.recalculateDeadwoodScore to calculate the deadwood score. Call Player.getDeadwoodScore method and check that the pre-calculated deadwood score matches the deadwood score received from call
    
    \item{FR-P-\textcolor{red}{\sout{5}6}: Test accessor for player's melds}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = [Ah, Ac, Ad, As, 2s, 2d, 2c, 3\textcolor{red}{d\sout{s}}, Qs, 9h];
    
    Input: p
    
    Output: melds = [[As, Ah, Ac, Ad],[2s, 2d, 2c]]
    
    How test will be performed: Call Player.checkMelds to calculate melds in the hand, then call Player.getMelds method and check that the melds yielded from the calculation are correct
    
    \item{FR-P-7: Test discarding a card that exists in the player's hand}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = \textcolor{red}{\sout{[4d, 8s, Jh]}[Ah, 2s, Qs, 3d, 5d]}
    
    Input: p.hand, \textcolor{red}{5d \sout{"jh"}}
    
    Output: p.hand = \textcolor{red}{\sout{[4d, 8s]}[Ah, 2s, Qs, 3d]}, new Card(Suit.\textcolor{red}{D\sout{H}, 5\sout{11}}) is returned.
    
    How test will be performed: Call Player.discardFromHand with a string representation of the card to discard. Verify that the card has been returned and that the hand no longer contains this card
    
    \item{FR-P-8: Test discarding a card that does not exist in the player's hand}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = \textcolor{red}{\sout{[4d, 8s, Kh, Qs, As]}[Ah, 2s, Qs, 3d, 5d]}
    
    Input: p, "jh"
    
    Output: \textcolor{red}{\sout{p.hand = [4d, 8s, Kh, Qs, As], null returned} \\ IllegalArgumentException}
    
    How test will be performed: Call Player.discardFromHand with a string representation of the non-existent card to discard. Verify that \textcolor{red}{\sout{a null output is returned, and the hand is unchanged.}an exception is raised from this call.}
    
    \item{FR-P-9: Test adding a score to the total score}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.totalScore = 1\textcolor{red}{2\sout{0}};
    
    Input: p, 15
    
    Output: p.totalScore = 2\textcolor{red}{7\sout{5}}
    
    How test will be performed: Call Player.getTotalScore to get the original score of 1\textcolor{red}{2\sout{0}}. Call Player.addToTotalScore with 15 as the parameter. Call Player.getTotalScore to get the new score. Verify that the original score added to the integer results in the new score, that is, 1\textcolor{red}{2\sout{0}} + 15 = 2\textcolor{red}{7\sout{5}}.
    
    \item{FR-P-10: Test getting deadwood cards from the player's hand}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = [Ah, Ac, Ad, 2s, 9\textcolor{red}{h\sout{s}}, 10h, Jd]
    
    Input: p
    
    Output: deadwoodCards = [2s, 9\textcolor{red}{h\sout{s}}, 10h, Jd]
    
    How test will be performed: Call Player.extractDeadwood
    
    \item{FR-P-11: Test recalculation of deadwood score}
    
    Type: Unit test, dynamic, automated
    					
    Initial state: p.hand = [Ah, Ac, Ad, 2s, 9s, 10h, Jd], p.deadwoodScore = \textcolor{red}{0\sout{45}}
    
    Input: p
    
    Output: p.deadwoodScore = 2 + 9 + 10 + 10 = 31
    
    How test will be performed: Call Player.recalculateDeadwoodScore to calculate the deadwood score. Call Player.getDeadwoodScore method and check that the pre-calculated deadwood score matches deadwood score received from call
    
    \item{FR-P-12: Test accessor for player's melds after checking for melds}
    
    Type: Integration test, dynamic, automated
    					
    Initial state: p.hand = [As, 2s, 3s, 4d, 5d, 6d, 7d, 10h], p.melds = [[As, 2s, 3s]]
    
    Input: p
    
    Output: p.melds = [[As, 2s, 3s], [4d, 5d, 6d, 7d]]
    
    How test will be performed: Call Player.checkMelds to calculate melds in the hand, then call Player.getMelds method and check that the melds yielded from the calculation are correct
    
    \item{FR-P-13: Test resetting hand}
    
    Type: Unit test, dynamic, automated	
    
    Initial state: p.hand = \textcolor{red}{[Ah, Ac, Ad, 2s, 9h, 10h, Jd]\sout{[Ah, 4d, 3s, 9d]}}
    
    Input: p
    
    Output: p.hand = []
    
    How test will be performed: Call Player.resetHand to reset the hand. Call Player.getHand to verify that the hand is an empty list
    
    \item{FR-P-14: Test resetting deadwood score}
    
    Type: Unit test, dynamic, automated	
    
    Initial state: p.deadwoodScore = \textcolor{red}{31\sout{15}}
    
    Input: p
    
    Output: p.deadwoodScore = 0
    
    How test will be performed: Call Player.resetDeadwoodScore to reset the deadwood score. Call Player.getDeadwoodScore to verify that the deadwood score is zero
    
    \item{FR-P-15: Test resetting list of melds}
    
    Type: Unit test, dynamic, automated	
    
    Initial state: p.melds = [[\textcolor{red}{Ah \sout{3s}}, \textcolor{red}{Ad \sout{4s}}, \textcolor{red}{Ac \sout{5s}}]]
    
    Input: p
    
    Output: p.melds = []
    
    How test will be performed: Call Player.resetMelds to reset list of melds. Call Player.getMelds to verify that the list of melds is empty
    
    
    \item{\textcolor{red}{FR-P-16: Test resetting total score}}
    
    \textcolor{red}{Type: Unit test, dynamic, automated}
    
    \textcolor{red}{Initial state: p.totalScore = 12}
    
    \textcolor{red}{Input: p}
    
    \textcolor{red}{Output: p.totalScore = 0}
    
    \textcolor{red}{How test will be performed: Call Player.resetTotalScore to reset the total score. Call Player.getTotalScore to verify that the total score is now 0}
\end{enumerate}

\subsubsection{Meld Tests}
% Meld Test %
\begin{enumerate}
    \item \textcolor{red}{\sout{{FR-M-1: Test sequence melds with minimum meld cards}}}
    
    \textcolor{red}{\sout{Type: Unit test, dynamic, functional test, automated}}
    
    \textcolor{red}{\sout{Initial state: Player hand has 11 cards}}
    
    \textcolor{red}{\sout{Input: Input Hand = Hand with Cards [3h, 7d, Qh, 4h, Kc, Kd, Ac, Ad, 5h, 6c, 6d ]}}
    
    \textcolor{red}{\sout{Output: InvalidHand Exception}}
    
    \textcolor{red}{\sout{How test will be performed: Call Meld.checkMelds}}
    
    \item{FR-M-\textcolor{red}{\sout{{2}}1}: Test sequence melds with more than 3 meld cards}
    
    Type: Unit test, dynamic, functional test, automated
    
    Initial state: Player hand has 4 cards in consecutive rank with same suit eg. 3S, 4S, 5S, 6S
    
    Input: Hand with Cards: [3s, 7d, Qh, 4s, Kc, Kd, Ac, Ad, 5s, 6s]
    
    Output: [[3S, 4S, 5S, 6S]] 
    
    How test will be performed: Call Meld.checkMelds
    
    \item{FR-M-\textcolor{red}{\sout{{3}}2}: Test melds with 3 cards of same rank}
    
    Type: Unit test, dynamic, functional test, automated 
    
    Initial state: Player's hand has 3 cards of same rank
    
    Input: Hand with Cards: [3s, 7d, Qh, 4s, Kc, Kd, Ac, Ad, Ah, 6s]
    
    Output:[\textcolor{red}{\sout{[Ac, Ad, Ah,]} [Ah, Ac, Ad]}]
    
    How test will be performed: Call Meld.checkMelds
    
    \item{FR-M-\textcolor{red}{\sout{{4}}3}: Test melds with 4 cards of same rank}
    
    Type: Unit test, dynamic, functional test, automated
    
    Initial state: Player's hand has 4 cards of same rank
    
    Input: Hand with Cards: [Kd,5d,4d,5c,Jc,Qd,5h,5s,3s,Js]
    
    Output:[[\textcolor{red}{\sout{5h,5s,5d,5c]}[5h,5s,5c,5d]}]
    
    How test will be performed: Call Meld.checkMelds
    
    \item{FR-M-\textcolor{red}{\sout{{5}}4}: Test meld with 2 sequence melds and one group meld}
    
    Type: Unit test, dynamic, functional test, automated
    
    Initial state: Player's hand has 2 sequence melds and one group meld
    
    Input: Hand with Cards: [3s,4s,5s, Kc,Jc,Qc,Ac,Ad,Ah,As]
    
    Output: [[3s,4s,5s],[Jc,Kc,Qc],\textcolor{red}{\sout{[Ac,Ad,Ah,As]} [Ah,As,Ac,Ad]}]
    
    How test will be performed: Call Meld.checkMelds
    
    \item{FR-M-\textcolor{red}{\sout{{6}}5}: Test meld with 1 sequence and 1 group meld}
    
    Type: Unit test, dynamic, functional test, automated
    
    Initial state: Player's hand has 1 sequence melds and 1 group meld
    
    Input:  Hand with Cards: [10c,Js, Ks, 10d, Qs, 10h, Ac, 4c, 6h, 9h ]
    
    Output:[[Js,Qs,Ks],\textcolor{red}{\sout{[10c,10d,10h]}[10h,10c,10d]}]
    
    How test will be performed: Call Meld.checkMelds
    
    \item{FR-M-\textcolor{red}{\sout{{7}}6}: Test Melds with overlapping cards}
    
    Type: Unit test, dynamic, functional test, automated 
    
    Initial state: Player's hand has a meld that can belong to a sequence and group meld
    
    Input: [Ac, Ad, Ah, As,2s,3s,Ks,Jh, Jd, 7s]
    
    Output: [[As,2s,3s],\textcolor{red}{\sout{[Ac,Ad,Ah]}[Ah,Ac,Ad]}]
    
    How test will be performed: Call Meld.checkMelds
\end{enumerate}

\subsubsection{UserInputOps Tests}
% UserInputOps Test %
\begin{enumerate}
    \item{\textcolor{red}{\sout{FR-UIO-1: Test that user can only discard cards that are in their hand}}}
    
    \textcolor{red}{\sout{Type: Unit test, dynamic, manual}}
    
    \textcolor{red}{\sout{Initial state: (Player) p.hand = [Ah, 4d, 5d, 8s, 10c]}}
    
    \textcolor{red}{\sout{Input: p, User inputs: "9d", "2s", "10c"}}
    
    \textcolor{red}{\sout{Output: "10c"}}
    
    \textcolor{red}{\sout{How test will be performed: Call UserInputOps.chooseDiscard method and enter input to test discard choice when prompted by the scanner - only cards that exist in the player's hand will terminate the test successfully}}
    
    \item{FR-UIO-\textcolor{red}{1\sout{2}}: Test that user inputting valid inputs for deciding on knocking results in successful termination}
    
    Type: Unit test, dynamic, combinatorial coverage-based, manual
    
    Initial state: N/A
    
    Input: User input: 'Y'
    
    Output: 'y'
    
    How test will be performed: Call UserInputOps.knock method and enter the valid input when prompted by the scanner
    
    \item{FR-UIO-\textcolor{red}{2\sout{3}}: Test that user inputting invalid inputs for deciding on knocking is handled properly}
    
    Type: Unit test, dynamic, partition-based, fuzz testing, manual
    
    Initial state: N/A
    
    Input: User inputs: 'h', 'e', 'l', 'l', 'o', "othello", "No"
    
    Output: 'n'
    
    How test will be performed: Call UserInputOps.knock method and enter a series of invalid inputs when prompted by the scanner. Termination should not occur until a valid input is received
    
    \item{FR-UIO-\textcolor{red}{3\sout{4}}: Test that user inputting valid inputs for deciding on playing a new game of Gin-Rummy results in successful termination}
    
    Type: Unit test, dynamic, combinatorial coverage-based, manual
    
    Initial state: N/A
    
    Input: User input: 'Y'
    
    Output: 'y'
    
    How test will be performed: Call UserInputOps.playAgain method and enter a valid input when prompted by the scanner
    
    \item{FR-UIO-\textcolor{red}{4\sout{5}}: Test that user inputting invalid inputs for deciding on playing a new game of Gin-Rummy is handled properly}
    
    Type: Unit test, dynamic, partition-based, fuzz testing, manual
    
    Initial state: N/A
    
    Input: User inputs: "To", "be", "or", "not", "to", "Be", "yEs"
    
    Output: 'n' - note that 'not' begins with n
    
    How test will be performed: Call UserInputOps.playAgain method and enter a series of invalid inputs when prompted by the scanner. Termination should not occur until a valid input is received
    
    \item{FR-UIO-\textcolor{red}{5\sout{6}}: Test/Simulate user making a valid decision in a single round}
    
    Type: Unit test, dynamic, combinatorial coverage-based, manual
    
    Initial state: N/A
    
    Input: 3
    
    Output: 3
    
    How test will be performed: Call UserInputOps.playerDecision method and enter a valid input
    
    \item{FR-UIO-\textcolor{red}{6\sout{7}}: Test that when the user making a invalid decision in a single round, it is handled appropriately}
    
    Type: Integration test, dynamic, partition-based, fuzz testing, manual
    
    Initial state: N/A
    
    Input: -1, 45, "hello", 'y', "tomorrow and tomorrow", 2
    
    Output: 2
    
    How test will be performed: Call UserInputOps.playerDecision method and enter a series of invalid inputs when prompted by the scanner. Test should not terminate successfully until a valid input is received.
    
    \item{FR-UIO-\textcolor{red}{7\sout{8}}: Test username is received properly}
    
    Type: Unit test, functional, dynamic, manual
    
    Initial state: N/A
    
    Input: "AC"
    
    Output: "AC"
    
    How test will be performed: Call UserInputOps.username method and enter username when prompted by the scanner
\end{enumerate}

\subsubsection{GameOps Tests}
%GameOps Tests
\begin{enumerate}
    \item{FR-GO-1: Test that score is calculated correctly and given to the right player (I)}
    
    Type: Unit test, dynamic, automated
    
    Initial state: (Player) p1.deadwoodScore = 10, p1.totalScore = 0, (Player) p2.deadwoodScore = 15, p2.totalScore = 0
    
    Input: p1, p2
    
    Output: p1.totalScore = 5, p2.totalScore = 0
    
    How the test will be performed: Call GameOps.calculateScore method with player deadwood score requirements
    
    \item{FR-GO-2: Test that score is calculated correctly and given to the right player (II)}
    
    Type: Unit test, dynamic, automated
    
    Initial state: p1.deadwoodScore = 20, p1.totalScore = 0, p2.deadwoodScore = 9, p2.totalScore = 0
    
    Input: p1, p2
    
    Output: p1.totalScore = 0, p2.totalScore = 11
    
    How the test will be performed: Call GameOps.calculateScore method with player deadwood score requirements
    
    \item{FR-GO-3: Test that going Gin works correctly}
    
    Type: Unit test, functional, dynamic, automated
    
    Initial state: p1.deadwoodScore = 0, p1.totalScore = 0, p2.deadwoodScore = 15, p2.totalScore = 0
    
    Input: p1, p2
    
    Output: p1.totalScore = 35, p2.totalScore = 0
    
    How the test will be performed: Call GameOps.calculateScore method with player deadwood score requirements
    
    \item{FR-GO-4: Test that stock pile is created correctly}
    Type: Unit test, functional, dynamic, automated
    
    Initial state: N/A
    
    Input: N/A
    
    Output: Stock Pile with 52 unique cards (A to K, all suits)
    
    How the test will be performed: Call GameOps.createStockPile
    
    \item{FR-GO-5: Test that discard pile is created correctly}
    Type: Unit test, functional, dynamic, automated
    
    Initial state: N/A
    
    Input: N/A
    
    Output: Empty stack/discard pile
    
    How the test will be performed: Call GameOps.createDiscardPile
    
    \item{\textcolor{red}{\sout{FR-GO-6: Test that card being discarded from player's hand ends up on top of the discard pile}}}
    
    \textcolor{red}{\sout{Type: Unit test, functional, dynamic, automated}}
    
    \textcolor{red}{\sout{Initial state: (Player) p.hand = [Ah, Ac, 5d, Jc], (DiscardPile) dp.peek = Qs}}
    
    \textcolor{red}{\sout{Input: "Jc"}}
    
    \textcolor{red}{\sout{Output: dp.top = Jc, p.hand = [Ah, Ac, 5d]}}
    
    \textcolor{red}{\sout{How the test will be performed: Call GameOps.discardCard}}
    
    \item{\textcolor{red}{\sout{FR-GO-7: Test that user can only discard cards that are in their hand}}}
    
    \textcolor{red}{\sout{Type: Integration test, functional, dynamic, manual}}
    
    \textcolor{red}{\sout{Initial state: p.hand = [Ah, Ac, 5d, Jc], dp.peek = Qs}}
    
    \textcolor{red}{\sout{Input: User inputs: "2s", "3d", "4s", "5d"}}
    
    \textcolor{red}{\sout{Output: p.hand = [Ah, Ac, Jc], dp.peek = 5d}}
    
    \textcolor{red}{\sout{How the test will be performed: Call UserInputOps.chooseDiscard to choose a card to discard. If the card does not exist in the player's hand, prompt again. After a valid input is received, GameOps.discardCard is called to discard the card.}}
    
    \item{FR-GO-\textcolor{red}{6\sout{8}}: Test that opening distribution of cards is done correctly}
    
    Type: Unit test, dynamic, automated
    
    Initial state: StockPile sp = createStockPile();
    
    Input: N/A
    
    Output: Player and cpu hands of size 10, discard pile of size 1, stock pile contains the rest of the cards
    
    How the test will be performed: Call GameOps.distributeCards with a brand new stock pile
    
    \item{FR-GO-\textcolor{red}{7\sout{9}}: Test that opening distribution of cards will only be done with a 52-card stock pile}
    Type: Unit test, functional, dynamic, automated
    
    Initial state: Stock pile of size 2\textcolor{red}{8\sout{5}}
    
    Input: N/A
    
    Output: Rejected status
    
    How the test will be performed: Call GameOps.distributeCards with the incorrect stock pile
    
    \item{\textcolor{red}{\sout{FR-GO-10: Test drawing from stock pile}}}
    
    \textcolor{red}{\sout{Type: Unit test, dynamic, automated}}
    
    \textcolor{red}{\sout{Initial state: p.hand = [Ah, Ad, 3d, 5c], sp.empty == false}}
    
    \textcolor{red}{\sout{Input: N/A}}
    
    \textcolor{red}{\sout{Output: p.hand = [Ah, Ad, 3d, 5c, New Card()]}}
    
    \textcolor{red}{\sout{How the test will be performed: Though the stock pile cannot be viewed, its sizes can be compared to confirm change has occurred}}
    
    \item{\textcolor{red}{\sout{FR-GO-11: Test drawing from discard pile}}}
    
    \textcolor{red}{\sout{Type: Unit test, functional, dynamic, automated}}
    
    \textcolor{red}{\sout{Initial state: p.hand = [Ah, Ad, 3d, 5c], dp.peek = Qd}}
    
    \textcolor{red}{\sout{Input: N/A}}
    
    \textcolor{red}{\sout{Output: p.hand = [Ah, Ad, 3d, 5c, Qd]}}
    
    \textcolor{red}{\sout{How the test will be performed: Call GameOps.drawFromDiscardPile method}}
    
    \item{FR-GO-\textcolor{red}{8\sout{12}}: Test interfacing playAgain method}
    Type: Integration test, functional, dynamic, manual
    
    Initial state: N/A
    
    Input: User inputs: 'A', 'B', 'n'
    
    Output: 'n'
    
    How the test will be performed: Call GameOps.playAgain method and enter the set of inputs. Only the valid inputs will result in a successful termination
    
    \item{FR-GO-\textcolor{red}{9\sout{13}}: Test process decision method}
    Type: Integration test, combinatorial coverage-based, dynamic, manual
    
    Initial state: New game has started
    
    Input: User's decision based on possible moves
    
    Output: Depends on move made - 1 will draw a card from the stock pile, 2 will draw a card from the discard pile, 3 will show melds, 4 will show deadwood score and prompt user if they wish to knock. If user knocks, return true, else return false
    
    How the test will be performed: Call GameOps.processDecision method\textcolor{red}{. The success of the test depends on what the user sees. No exceptions should occur, termination should be successful.}
    
    \item{FR-GO-1\textcolor{red}{0\sout{4}}: Test reset for a new deal}
    Type: Integration test, functional, dynamic, automated
    
    Initial state: p.hand = [Ah, Ac, Ad, 6s], p.deadwoodScore = 6, p.melds = [Ah, Ac, Ad]
    
    Input: N/A
    
    Output: p.hand = [], p.melds = [], p.deadwoodScore = 0
    
    How the test will be performed: Call GameOps.resetEverything method
    
    \item{FR-GO-1\textcolor{red}{1\sout{5}}: Test interfacing username method}
    
    Type: Integration test, dynamic, manual
    
    Initial state: N/A
    
    Input: "AC"
    
    Output: "AC"
    
    How test will be performed: Call GameOps.username method and enter username when prompted by the underlying Scanner
    
    \item{\textcolor{red}{FR-GO-12: Test decision making when stock pile is empty}}
    
    \textcolor{red}{Type: Unit test, dynamic, manual}
    
    \textcolor{red}{Initial state: (StockPile) sp = new StockPile()}
    
    \textcolor{red}{Input: User inputs 1 when prompted}
    
    \textcolor{red}{Output: User should not be allowed to draw from the stock pile and is prompted to make a new valid decision}
    
    \textcolor{red}{How test will be performed: Call GameOps.processDecision and enter specified input}
\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Look and Feel Requirements}

\paragraph{NFR-LF-1: Test game appearance\\}

Type: Unit test, non-functional, dynamic, manual

Initial state: Cards dealt, player's hand and discard pile displayed

Input: N/A

Output: Cards displayed have a simplistic look

How the test will be performed: Manually check the look of the cards

\subsubsection{Usability and Humanity Requirements}

\paragraph{NFR-UH-1: Test game Usability\\}

Type: System test, non-functional, dynamic, manual

Initial state: Cards dealt, player's hand and discard pile displayed

Input: N/A

Output: Easily set up and play the game

How the test will be performed: Manually set up and play game to check the ease of use

\subsubsection{Performance Requirements}

\paragraph{NFR-P-1: Test performance speed\\}

Type: System testing, non-functional, dynamic, manual

Initial state: Start a new game 

Input: User interactions with system

Output: System should respond within 0.5 seconds of user input, according to the non-functional requirements

How the test will be performed: Play a round of the game manually and time the system response

\paragraph{NFR-P-2: Test game rules requirements\\}

Type: System testing, non-functional, dynamic, manual

Initial state: N/A

Input: N/A

Output: Legal moves (according to game rules) can be done without errors. User's prompted for another input if they are making an illegal move

How the test will be performed: Manually play the game to make sure all legal moves can be made and any illegal moves are prevented

\subsubsection{Operational and Environmental Requirements}

\paragraph{NFR-OE-1: Test operational requirements\\}

Type: System testing, non-functional, static, manual

Initial state: N/A

Input: N/A

Output: Game can be played on various operating systems

How the test will be performed: Manually test that the program can be operated on Windows, Linux, and MacOS operating system

\subsubsection{Maintainability and Support Requirements}

\paragraph{NFR-MS-1: Test maintainability requirements\\}

Type: System testing, non-functional, manual

Initial state: N/A

Input: N/A

Output: Well documented source code as well as game rules and how to run the game for users

How the test will be performed: Manually test that the program is well documented

\subsubsection{Cultural Requirements}

\paragraph{NFR-C-1: Test cultural requirements\\}

Type: System testing, non-functional, dynamic, manual

Initial state: N/A

Input: N/A

Output: No offensive images or text in source code or displayed to users

How the test will be performed: Manually test that there are no offensive images or text

\paragraph{NFR-C-2: Test cultural requirements\\}

Type: System testing, non-functional, dynamic, manual

Initial state: N/A

Input: N/A

Output: Game console output is all in English

How the test will be performed: Manually test that everything displayed to the user is in English

\subsubsection{Legal Requirements}

\paragraph{NFR-L-1: Test legal requirements\\}

Type: System testing, non-functional, static, manual

Initial state: N/A

Input: N/A

Output: Adherence to copyright properties

How the test will be performed: Manually test the adherence to copyright properties under the MIT license

\subsection{Traceability Between Test Cases and Requirements}
\begin{table}[H]
    \centering
    \caption{Traceability Matrix: Functional Requirement}
    \begin{adjustbox}{max width=0.7\paperwidth}
    \begin{tabular}{l|ccccccccccc}
        \textbf{Test IDs} & \multicolumn{7}{c}{\textbf{Requirement IDs}}\\
        \hline
        ~ & \textbf{BE1} & \textbf{BE2} & \textbf{BE3} & \textbf{BE4} & \textbf{BE5} & \textbf{BE6} & \textbf{BE7} & \textbf{BE8}\\
        \textbf{FR-C-1}    &\textcolor{red}{X}  & X & X & X & X & \textcolor{red}{X} & ~ & ~\\
        \textbf{FR-C-2}    &\textcolor{red}{X} & X & X & X & X & \textcolor{red}{X} & ~ & ~\\
        \textbf{FR-C-3}    &\textcolor{red}{X} & X & X & X & X & \textcolor{red}{X} & ~ & ~\\
        \textbf{FR-C-4}    &\textcolor{red}{X} & X & X & X & X &\textcolor{red}{X} & ~ & ~\\
        \textbf{FR-C-5}    &\textcolor{red}{X} & X & X & X & X &\textcolor{red}{X} & ~ & ~\\
        \textbf{FR-C-6}    &\textcolor{red}{X} & X & X & X & X & \textcolor{red}{X} & ~ & ~\\
        \textbf{\textcolor{red}{{FR-C-7} }} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & ~ & ~\\
        \textbf{\textcolor{red}{{FR-C-8} }} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & ~ & ~\\
        \textbf{FR-DP-1}   & ~ & ~ & X & ~ & ~ & X & ~ & ~\\
        \textbf{FR-DP-2}   & ~ & ~ & X & ~ & ~ & X & ~ & ~\\
        \textbf{FR-SP-1}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\sout{\textbf{FR-SP-2}}}   & ~ & \textcolor{red}{\sout{X}} & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-1}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-2}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-3}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-4}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-5}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-CP-6}   & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\textbf{FR-CP-7}}   & ~ & \textcolor{red}{X} & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\textbf{FR-CP-8}}   & ~ & \textcolor{red}{X} & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-H-1}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-2}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-3}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-4}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-5}    & X & X & X & ~ & X & X & ~ & ~\\
        \textbf{FR-H-6}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-7}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-8}    & X & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-H-9}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
    \end{tabular}
    \end{adjustbox}
    \label{Traceability Matrix: Functional Requirement}
\end{table}

\begin{table}[H]
    \centering
    \begin{adjustbox}{max width=0.7\paperwidth}
    \begin{tabular}{l|ccccccccccc}
        \textbf{Test IDs} & \multicolumn{7}{c}{\textbf{Requirement IDs}}\\
        \hline
        ~ & \textbf{BE1} & \textbf{BE2} & \textbf{BE3} & \textbf{BE4} & \textbf{BE5} & \textbf{BE6} & \textbf{BE7} & \textbf{BE8}\\
        \textbf{FR-P-1}    & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-P-2}    & ~ & X & X & \textcolor{red}{\sout{X}} & \textcolor{red}{\sout{X}} & \textcolor{red}{\sout{X}} & \textcolor{red}{\sout{X}} & ~\\
        \textbf{FR-P-3}    & ~ & \textcolor{red}{X} & \textcolor{red}{X} & \textcolor{red}{X} & X & \textcolor{red}{X} & \textcolor{red}{X} & ~\\
        \textbf{FR-P-4}    & ~ & ~ & ~ & ~ & \textcolor{red}{X} & ~ & \textcolor{red}{\sout{X}} & ~\\
        \textbf{FR-P-5}    & ~ & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~ & \textcolor{red}{X} & ~\\
        \textbf{FR-P-6}    & ~ & \textcolor{red}{\sout{X}} & \textcolor{red}{\sout{X}} & \textcolor{red}{X} & ~ & ~ & ~ & ~\\
        \textbf{FR-P-7}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-P-8}    & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{FR-P-9}    & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-P-10}   & ~ & ~ & ~ & ~ & X & ~ & X & ~\\
        \textbf{FR-P-11}   & ~ & ~ & ~ & ~ & X & ~ & X & ~\\
        \textbf{FR-P-12}   & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-P-13}   & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-P-14}   & X & ~ & ~ & ~ & X & ~ & ~ & ~\\
        \textbf{FR-P-15}   & ~ & ~ & ~ & X & ~ & ~ & ~ & ~\\
        \textcolor{red}{\textbf{FR-P-16}}   & \textcolor{red}{X} & \textcolor{red}{~} & \textcolor{red}{~} & \textcolor{red}{~} & \textcolor{red}{X} & \textcolor{red}{~} & \textcolor{red}{~} & \textcolor{red}{~} \\
        \textbf{FR-M-1}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-M-2}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-M-3}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-M-4}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-M-5}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{FR-M-6}    & ~ & ~ & ~ & X & ~ & ~ & X & ~\\
        \textbf{\textcolor{red}{\sout{FR-M-7}}}    & ~ & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~ & \textcolor{red}{\sout{X}} & ~\\
        \textcolor{red}{\sout{\textbf{FR-UIO-1}}}  & ~ & ~ & ~ & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{2}1}}  & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{3}2}}  & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{4}3}}  & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{5}4}}  & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{6}5}}  & ~ & X & X & X & X & ~ & X & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{7}6}}  & ~ & X & X & X & X & ~ & X & ~\\
        \textbf{FR-UIO-\textcolor{red}{\sout{8}7}}  & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
    \end{tabular}
    \end{adjustbox}
\end{table}

\begin{table}[H]
    \centering
    \begin{adjustbox}{max width=0.7\paperwidth}
    \begin{tabular}{l|ccccccccccc}
        \textbf{Test IDs} & \multicolumn{7}{c}{\textbf{Requirement IDs}}\\
        \hline
        ~ & \textbf{BE1} & \textbf{BE2} & \textbf{BE3} & \textbf{BE4} & \textbf{BE5} & \textbf{BE6} & \textbf{BE7} & \textbf{BE8}\\
        \textbf{FR-GO-1}     & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-GO-2}     & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-GO-3}     & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{FR-GO-4}     & X & ~ & ~ & ~ & ~ & ~ & ~ & X\\
        \textbf{FR-GO-5}     & X & ~ & ~ & ~ & ~ & ~ & ~ & X\\
        \textcolor{red}{\sout{\textbf{FR-GO-6}}}     & ~ & ~ & ~ & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~\\
        \textcolor{red}{\sout{\textbf{FR-GO-7}}}     & ~ & ~ & ~ & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~\\
        \textbf{FR-GO-\textcolor{red}{\sout{8}6}}     & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-GO-\textcolor{red}{\sout{9}7}}     & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\sout{\textbf{FR-GO-10}}}    & ~ & \textcolor{red}{\sout{X}} & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\sout{\textbf{FR-GO-11}}}    & ~ & ~ & \textcolor{red}{\sout{X}} & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-GO-\textcolor{red}{\sout{12}8}}    & ~ & ~ & ~ & ~ & ~ & ~ & ~ & X\\
        \textbf{FR-GO-\textcolor{red}{\sout{13}9}}    & ~ & X & X & X & X & ~ & X & ~\\
        \textbf{FR-GO-1\textcolor{red}{0\sout{4}}}    & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{FR-GO-1\textcolor{red}{1\sout{5}}}    & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textcolor{red}{\textbf{FR-GO-12}}   & ~ & \textcolor{red}{X} & ~ & ~ & ~ & ~ & ~ & ~ \\
    \end{tabular}
    \end{adjustbox}
\end{table}

\begin{table}[H]
    \centering
    \caption{Traceability Matrix: Non-Functional Requirement}
    \begin{adjustbox}{max width=0.7\paperwidth}
    \begin{tabular}{l|ccccccccccccccc}
        \textbf{Test IDs} & \multicolumn{9}{c}{\textbf{Requirement IDs}}\\
        \hline
        ~ & \textbf{LF1} & \textbf{UH1} & \textbf{P1} & \textbf{P2} & \textbf{OE1}
        & \textbf{MS1} & \textbf{C1} & \textbf{C2} & \textbf{L1}\\
        \textbf{NFR-LF-1}  & X & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{NFR-UH-1}  & ~ & X & ~ & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{NFR-P-1}   & ~ & ~ & X & ~ & ~ & ~ & ~ & ~ & ~\\
        \textbf{NFR-P-2}   & ~ & ~ & ~ & X & ~ & ~ & ~ & ~ & ~\\
        \textbf{NFR-OE-1}  & ~ & ~ & ~ & ~ & X & ~ & ~ & ~ & ~\\
        \textbf{NFR-MS-1}  & ~ & ~ & ~ & ~ & ~ & X & ~ & ~ & ~\\
        \textbf{NFR-C-1}   & ~ & ~ & ~ & ~ & ~ & ~ & X & ~ & ~\\
        \textbf{NFR-C-2}   & ~ & ~ & ~ & ~ & ~ & ~ & ~ & X & ~\\
        \textbf{NFR-L-1}   & ~ & ~ & ~ & ~ & ~ & ~ & ~ & ~ & X\\
    \end{tabular}
    \end{adjustbox}
    \label{Traceability Matrix: Non-Functional Requirement}
\end{table}

\section{System Tests for Proof of Concept}

\begin{enumerate}

\item{FC-1 (Testing Sequence Melds)}

Type: Functional, dynamic, manual
					
Initial State: Hand of 10 cards with one sequence meld
					
Input/Condition: Hand of Cards
					
Output/Result: List of one sequence meld
					
How test will be performed: With a main method that calls on the public class
					
\item{FC-2 (Testing Group Meld)}

Type: Functional, dynamic, manual
					
Initial State: Hand of 10 cards with one group meld
					
Input/Condition: Hand of Cards
					
Output: List of one group melds
					
How test will be performed: With a main method, that calls on the public method

\item{FC-3 (Testing drawing from discard pile)}

Type: Functional, dynamic, manual
					
Initial State: Player has made a decision
					
Input: String input of the card the player wants to draw
					
Output: Card added to player hand
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-4 (Testing unique display of cards)}

Type: Functional, dynamic, manual
					
Initial State: New Game
					
Input: N/A
					
Output: Game options
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-5 (Testing discard pile)}

Type: Functional, dynamic, manual
					
Initial State: Player wants to check discard pile for card
					
Input: N/A
					
Output: Game options
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-6 (Testing computer turns)}

Type: Functional, dynamic, manual
					
Initial State: New Game
					
Input: Scanner inputs
					
Output: Game options
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-7 (Testing drawing from stock pile}

Type: Functional, dynamic, manual
					
Initial State: Player wants to draw from pile
					
Input: Scanner Input
					
Output: Card added to player hand
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-8 (Testing Check melds)}

Type: Functional, dynamic, manual
					
Initial State: Player wants to check melds
					
Input: Scanner Input
					
Output: List of melds displayed
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-9 (Testing Check deadwood score/knock)}

Type: Functional, dynamic, manual
					
Initial State: Players wants to check deadwood score or knock
					
Input: Scanner Input
					
Output: Deadwood score displayed and if applicable knock option prompted
					
How test will be performed: Exploratory test of the whole game system.

\item{FC-10 (Testing discard a card)}

Type: Functional, dynamic, manual
					
Initial State: Player wants to discard a card
					
Input: String representation of the card to be discarded.
					
Output: New hand with the previous card no longer there
					
How test will be performed: Exploratory test of the whole game system.
\end{enumerate}

	
\section{Comparison to Existing Implementation}
These tests compare the program to the Go implementation.
\begin{itemize}
    \item NFR-LF-1 Test Game Appearance
    \item NFR-MS-1 Test Maintainability Requirements
\end{itemize}

\section{Unit Testing Plan}
		
\subsection{Unit testing of internal functions}
Unit testing of internal functions will involve testing methods with return outputs. Assertion statements will be used to assess the correctness of the output from the internal functions. The expectation is that this output matches the expected output. 

Coverage-based test cases will also be used. The goal is to ensure statement, condition and branch coverage. Boundary test-cases will be used for exception catching and handling, and to test user input.

\subsection{Unit testing of output files}		
Not applicable for this system.

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

N/A

\end{document}